//==================================================1.ООП=============================================================//

//Когда мы пишем наш код, используя объекты для представления сущностей реального мира,
//– это называется объектно-ориентированное программирование или сокращённо: «ООП».
//ООП является большой предметной областью и интересной наукой само по себе.
//Как выбрать правильные сущности? Как организовать взаимодействие между ними?
//Это – создание архитектуры, и есть хорошие книги по этой теме, такие как «Приёмы объектно-ориентированного проектирования.
//Паттерны проектирования» авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес или «Объектно-ориентированный
//анализ и проектирование с примерами приложений» Гради Буча, а также ещё множество других книг.

//Функции, которые находятся в объекте в качестве его свойств, называются «методами».
//Методы позволяют объектам «действовать»: object.doSomething().
//Методы могут ссылаться на объект через this.Значение this определяется во время исполнения кода.
//При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
//Эта функция может быть скопирована между объектами (из одного объекта в другой).
//Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.
//Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this.
//Когда внутри стрелочной функции обращаются к this, то его значение берётся снаружи.

//При объектно-ориентированном подходе каждый объект должен представлять собой интуитивно понятную сущность,
// у которой есть методы и данные.
// В JavaScript объекты часто используются просто как коллекции.Например, встроенный объект Math
// содержит функции (Math.sin, Math.pow, …) и данные (константа Math.PI).При таком использовании объектов
// мы не можем сказать, что «применён объектно-ориентированный подход».
// В частности, никакую «единую сущность» Math из себя не представляет, это просто коллекция независимых функций
// с общим префиксом Math.

//Классом в объектно-ориентированной разработке называют шаблон/программный код,
//предназначенный для создания объектов и методов.
//В объектно-ориентированном программировании свойства и методы разделены на 2 группы:
//Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
//Внешний интерфейс – методы и свойства, доступные снаружи класса.
//В JavaScript есть два типа полей (свойств и методов) объекта:
//Публичные: доступны отовсюду. Они составляют внешний интерфейс.
//До этого момента мы использовали только публичные свойства и методы.
//Приватные: доступны только внутри класса. Они для внутреннего интерфейса.

//В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.


//===================================2.SOLID(ОБЬКТНО0ОРИЕНТИРОВАННОЕ ПРОЕКТИРОВАНИЕ)==================================//

//SOLID (сокр. от англ. single responsibility, open–closed, Liskov substitution, interface segregation и dependency inversion)
//в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов,
//названных Робертом Мартином в начале 2000-х, которые означали
//5 основных принципов объектно-ориентированного программирования и проектирования.

//При создании программных систем использование принципов SOLID способствует созданию такой системы,
//которую будет легко поддерживать и расширять в течение долгого времени.Принципы SOLID — это руководства,
//которые также могут применяться во время работы над существующим программным обеспечением для его улучшения,
//например, для удаления «дурно пахнущего кода».
//Стратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.

//SRP//Принцип единственной ответственности (single responsibility principle)//
//Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления,
//должны быть инкапсулированы в этот класс и подчинены только этой задаче.

//OCP//Принцип открытости/закрытости (open-closed principle)//
//«программные сущности … должны быть открыты для расширения, но закрыты для модификации».

//LSP//Принцип подстановки Лисков (Liskov substitution principle)//
//«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы»
//Производный класс должен быть взаимозаменяем с родительским классом.

//ISP//Принцип разделения интерфейса (interface segregation principle)//
//«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения».

//DIP//Принцип инверсии зависимостей (dependency inversion principle)//
//«Зависимость на Абстракциях. Нет зависимости на что-то конкретное»

//========================================3.ФУНКЦИОНАЛЬНОЕ ПРОГРАМИРОВАНИЕ.==========================================//

//Функциона́льное программи́рование — парадигма программирования, в которой процесс вычисления трактуется
//как вычисление значений функций в математическом понимании последних
//(в отличие от функций как подпрограмм в процедурном программировании).
// Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных
//и результатов других функций, и не предполагает явного хранения состояния программы.
//Соответственно, не предполагает оно и изменяемость этого состояния
//(в отличие от императивного, где одной из базовых концепций является переменная,
//хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).
//На практике отличие математической функции от понятия «функции» в императивном программировании заключается в том,
//что императивные функции могут опираться не только на аргументы,
//но и на состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять состояние
//внешних переменных. Таким образом, в императивном программировании при вызове одной и той же функции с одинаковыми
//параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию
//состояния переменных.А в функциональном языке при вызове функции с одними и теми же аргументами мы всегда получим
//одинаковый результат: выходные данные зависят только от входных. Это позволяет средам выполнения программ на
//функциональных языках кешировать результаты функций и вызывать их в порядке, не определяемом алгоритмом и
//распараллеливать их без каких-либо дополнительных действий со стороны программиста (что обеспечивают функции без
//побочных эффектов — чистые функции..
//Лямбда-исчисление является основой для функционального программирования, многие функциональные языки можно
//рассматривать как «надстройку» над ним.

//Наиболее известными языками функционального программирования являются:
// Лисп (Джон Маккарти, 1958) и множество его диалектов, наиболее известные — Scheme, Clojure и Common Lisp;
// Erlang (Джо Армстронг, 1986) — функциональный язык с поддержкой процессов, а также его прямой потомок Elixir;
// APL — предшественник современных научных вычислительных сред, таких как MATLAB;
// ML (Робин Милнер, 1979) и его основные диалекты Standard ML и OCaml;
// F# — функциональный язык семейства ML для платформы .NET;
// Scala;
// Miranda (Дэвид Тёрнер, 1985) и его прямой потомок чистый функциональный язык Haskell;
// Nemerle — гибридный функционально-императивный язык.

//====================================4.ТИПЫ ДАННЫХ В JS, ОТЛИЧИЕ ПРИМИТИВОВ ОТ ОБЬКТОВ.==============================//

//В JavaScript есть 8 основных типов.
//==number== для любых чисел: целочисленных или чисел с плавающей точкой;
//целочисленные значения ограничены диапазоном ±(253-1).
//Числовой тип данных ==(number)== представляет как целочисленные значения, так и числа с плавающей точкой.
//Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.
//Кроме обычных чисел, существуют так называемые «специальные числовые значения»,
//которые относятся к этому типу данных: ==Infinity, -Infinity и NaN==.
//Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
//Мы можем получить его в результате деления на ноль.
let message = "hello";
message = 123456;

alert( 1 / 0 ); // Infinity

//В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), или меньше,
//чем -(253-1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.
//Для большинства случаев этого достаточно. Но иногда нам нужны действительно гигантские числа, например,
//в криптографии или при использовании метки времени («timestamp») с микросекундами.

//==bigint== для целых чисел произвольной длины.
//Тип ==BigInt== был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.
//Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала.
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;


//==string== для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
//Строка ==(string)== в JavaScript должна быть заключена в кавычки.
//В JavaScript существует три типа кавычек.
// Двойные кавычки: "Привет".
// Одинарные кавычки: 'Привет'.
// Обратные кавычки: `Привет`.
//Выражение внутри ${…} вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно:
//переменную name, или выражение 1 + 2, или что-то более сложное.
alert( "результат: ${1 + 2}" ); // результат: ${1 + 2} (двойные кавычки ничего не делают)

//==boolean== для true/false.
//Булевый тип ==(boolean)== может принимать только два значения: true (истина) и false (ложь).
//Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно»,
//а false значит «нет, не правильно».
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

//==null== для неизвестных значений – отдельный тип, имеющий одно значение null.
//Специальное значение null не относится ни к одному из типов, описанных выше.
//Оно формирует отдельный тип, который содержит только значение null.
//В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем»,
//как в некоторых других языках.
//Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
//В приведённом выше коде указано, что значение переменной age неизвестно.
let age = null;

//==undefined== для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
//Специальное значение ==undefined== также стоит особняком. Оно формирует тип из самого себя так же, как и null.
//Оно означает, что «значение не было присвоено».
//Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined.
let age;
alert(age); // выведет "undefined"

//==object== для более сложных структур данных.
//Тип object (объект) – особенный.
//Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения
//(будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.
// Объекты занимают важное место в языке и требуют особого внимания.

//Тип ==symbol== (символ) используется для создания уникальных идентификаторов в объектах.
//Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.
// symbol для уникальных идентификаторов.

// Оператор==typeof== позволяет нам увидеть, какой тип данных сохранён в переменной.
//Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов
//по-разному или просто хотим сделать проверку.
//У него есть две синтаксические формы:
//1.Синтаксис оператора: typeof x.
typeof undefined // "undefined"
//2.Синтаксис функции: typeof(x).
typeof Math // "object"  (1)

//=============5.Хоистинг в жс, отличие var и let; function declaration vs expression vs стрелочные функции===========//
//Функция в JavaScript – это не магическая языковая структура, а особого типа значение.
// Синтаксис, который мы использовали до этого, называется Function Declaration (Объявление Функции):
 function sayHi() {
  alert( "Привет" );
 }
// Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).
// Оно выглядит вот так:
 let sayHi = function() {
   alert( "Привет" );
 };

//Объявление Function Declaration (1) создало функцию и присвоило её значение переменной с именем sayHi.
//В строке (2) мы скопировали её значение в переменную func.
//Обратите внимание (ещё раз): нет круглых скобок после sayHi. Если бы они были,
//то выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi.
//Теперь функция может быть вызвана с помощью обеих переменных sayHi() и func().
//Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
// Function Declaration
function sum(a, b) {
 return a + b;
}

//Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции.
//В данном случае функция создаётся в правой части «выражения присваивания».
// Function Expression
let sum = function(a, b) {
 return a + b;
};

//Более тонкое отличие состоит, в том, когда создаётся функция движком JavaScript.
//Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
//После того, как поток выполнения достигнет правой части выражения присваивания
//let sum = function… – с этого момента, функция считается созданной
//и может быть использована (присвоена переменной, вызвана и т.д. ).
//С Function Declaration всё иначе.
//Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).
//Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём
//Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».
//И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.
//В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

//Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration,
//который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код.
//Функции, объявленные таким образом, можно вызывать до их объявления.
//Также функции вида function f(…) {…} чуть более заметны в коде, чем let f = function(…) {…}.
//Function Declaration легче «ловятся глазами».
//…Но если Function Declaration нам не подходит по какой-то причине (мы рассмотрели это в примере выше),
//то можно использовать объявление при помощи Function Expression.

//============================================6.ОБЛАСТЬ ВИДИМОСТИ.====================================================//
//Область видимости переменных var ограничивается либо функцией, либо, если переменная глобальная, то скриптом.
//Такие переменные доступны за пределами блока.
//Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта,
//если переменная является глобальной).
//Другими словами, переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того,
//в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).

//Существует 2 основных отличия var от let/const:
//Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
//Объявления (инициализация) переменных varпроизводится в начале исполнения функции
//(или скрипта для глобальных переменных).
//Есть ещё одно небольшое отличие, относящееся к глобальному объекту, мы рассмотрим его в следующей главе.
//Эти особенности, как правило, не очень хорошо влияют на код. Блочная область видимости – это удобно.
//Поэтому много лет назад let и const были введены в стандарт и сейчас являются основным способом объявления переменных.

//=================================================7.ЗАМЫКАНИЕ.=======================================================//
//Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.
//Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции.
//В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
function init() {
 var name = "Mozilla"; // name - локальная переменная, созданная в init
 function displayName() { // displayName() - внутренняя функция, замыкание
  alert (name); // displayName() использует переменную, объявленную в родительской функции
 }
 displayName();
}
init();
//init() создаёт локальную переменную name и определяет функцию displayName().
//displayName() — это внутренняя функция — она определена внутри init() и доступна только внутри тела функции init().
//Обратите внимание, что функция displayName() не имеет никаких собственных локальных переменных.
//Однако, поскольку внутренние функции имеют доступ к переменным внешних функций, displayName() может иметь доступ
//к переменной name, объявленной в родительской функции init().
//Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена.
//Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции
//во время создания замыкания.

//Замыкания полезны тем, что позволяют связать данные (лексическое окружение) с функцией, которая работает
//с этими данными. Очевидна параллель с объектно-ориентированным программированием, где объекты позволяют нам связать
//некоторые данные (свойства объекта) с одним или несколькими методами.
//Cледовательно, замыкания можно использовать везде, где вы обычно использовали объект с одним единственным методом.
//Такие ситуации повсеместно встречаются в web-разработке. Большое количество front-end кода,
//который мы пишем на JavaScript, основано на обработке событий. Мы описываем какое-то поведение,
//а потом связываем его с событием, которое создаётся пользователем (например, клик мышкой или нажатие клавиши).
//При этом наш код обычно привязывается к событию в виде обратного/ответного вызова (callback):
//callback функция - функция выполняемая в ответ на возникновение события.

//==========================================8.КОНТЕКСТ.ПОТЕРЯ THIS.ПРИВЯЗКА КОНТЕКСТА=================================//
//При передаче методов объекта в качестве колбэков, например для setTimeout, возникает известная проблема – потеря this.
//Мы уже видели примеры потери this. Как только метод передаётся отдельно от объекта – this теряется.
let user = {
 firstName: "Вася",
 sayHi() {
  alert(`Привет, ${this.firstName}!`);
 }
};

setTimeout(user.sayHi, 1000); // Привет, undefined!

//При запуске этого кода мы видим, что вызов this.firstName возвращает не «Вася», а undefined!
//Это произошло потому, что setTimeout получил функцию sayHi отдельно от объекта user
//(именно здесь функция и потеряла контекст). То есть последняя строка может быть переписана как:
 let f = user.sayHi;
 setTimeout(f, 1000); // контекст user потеряли

//Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:

let user = {
   firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
 };

 setTimeout(function() {
   user.sayHi(); // Привет, Вася!
 }, 1000);

 //В современном JavaScript у функций есть встроенный метод bind, который позволяет зафиксировать this.
// Базовый синтаксис bind:полный синтаксис будет представлен немного позже
let boundFunc = func.bind(context);
//Результатом вызова func.bind(context) является особый «экзотический объект» (термин взят из спецификации),
//который вызывается как функция и прозрачно передаёт вызов в func, при этом устанавливая this=context.
//Другими словами, вызов boundFunc подобен вызову func с фиксированным this.
// Например, здесь funcUser передаёт вызов в func, фиксируя this=user:

 let user = {
   firstName: "Вася"
 };

 function func() {
   alert(this.firstName);
 }

 let funcUser = func.bind(user);
 funcUser(); // Вася
//Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user

//Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…,
//если они заданы.
//Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка.
//Например, для setTimeout.
//Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».
//Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз.
//Например, если у нас есть функция send(from, to) и from всё время будет одинаков для нашей задачи,
//то мы можем создать частично применённую функцию и дальше работать с ней.

//==============================================9.МЕТОДЫ МАССИВОВ=====================================================//
//arr.push(...items) – добавляет элементы в конец,
//arr.pop() – извлекает элемент из конца,
//arr.shift() – извлекает элемент из начала,
//arr.unshift(...items) – добавляет элементы в начало.
//Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять,
//удалять и заменять элементы.
// Его синтаксис:
 arr.splice(index[, deleteCount, elem1, ..., elemN])
//Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
//Возвращает массив из удалённых элементов.

//Метод arr.slice намного проще, чем похожий на него arr.splice.
//Его синтаксис:
 arr.slice([start], [end])
//Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
//Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
// Это похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.

//Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
arr.concat(arg1, arg2...)
//Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
//В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
//Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

//Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
//Его синтаксис:
 arr.forEach(function(item, index, array) {
   // ... делать что-то с item
 });
 //Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое,
//что и их строковые аналоги, но работают с элементами вместо символов:
//arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент
//в противном случае -1.
//arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
//arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

//Для поиска обьекта в массиве обьектов с определенным условием используют arr.find
//let result = arr.find(function(item, index, array) {
//если true - возвращается текущий элемент и перебор прерывается
//если все итерации оказались ложными, возвращается undefined
// });
// Функция вызывается по очереди для каждого элемента массива:
// item – очередной элемент.
// index – его индекс.
// array – сам массив.

//Метод find ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true.
// На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).
// Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:
let results = arr.filter(function(item, index, array) {
// если true - элемент добавляется к результату, и перебор продолжается
//   // возвращается пустой массив в случае, если ничего не найдено
 });

//Метод arr.map является одним из наиболее полезных и часто используемых.
//Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
 let result = arr.map(function(item, index, array) {
//   // возвращается новое значение вместо элемента
 });

 //Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
// Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
 let arr = [ 1, 2, 15 ];
// // метод сортирует содержимое arr
arr.sort();
alert( arr );  // 1, 15, 2

//Метод arr.reverse меняет порядок элементов в arr на обратный.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1

//Метод str.split(delim) разбивает строку на массив по заданному разделителю delim.
 let names = 'Вася, Петя, Маша';
 let arr = names.split(', ');
 for (let name of arr) {
 alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
 }

 //Вызов arr.join(glue) делает в точности противоположное split.
//Он создаёт строку из элементов arr, вставляя glue между ними.
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша

//reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и
//передавая промежуточный результат между вызовами.
let value = arr.reduce(function(previousValue, item, index, array) {
    // ...
}, [initial]);

//================================================10.МЕТОДЫ ОБЪЕКТОВ.==================================================//
//Метод Object.create() позволяет создавать новые объекты и соединять их с прототипами существующих объектов.
//Метод Object.create() полезен для хранения кода DRY благодаря минимизации дублирования.

//Метод Object.keys() создает массив ключей объекта.
// Создайте объект и отобразите его массив ключей.
// Метод Object.keys можно использовать для итерации по ключам и значениям объектов.

//Метод Object.values() создает массив значений объекта.
//Методы Object.keys() и Object.values() позволяют возвращать данные объекта.

//Метод Object.entries() создает вложенный массив пар «ключ-значение» объекта.
//Метод Object.entries() возвращает только свойства экземпляра объекта, а не унаследованные свойства прототипа.

//Метод Object.assign() копирует значения из одного объекта в другой.
//Создайте два объекта и объедините их с помощью этого метода.

//Метод Object.freeze() предотвращает модификацию свойств и значений объекта и добавление или удаление свойств объекта.
//Метод Object.isFrozen() позволяет определить, был ли объект заморожен или нет, и возвращает логическое значение.

//Метод Object.seal()предотвращает добавление новых свойств объекта, но позволяет изменять существующие свойства.
//Этот метод похож на Object.freeze(). Обновите консоль, прежде чем выполнить нижеприведенный код, чтобы избежать ошибки.

//Метод Object.getPrototypeOf() используется для получения внутреннего скрытого [[Prototype]] объекта,
//также доступного через свойство __proto__.
//Этот метод может предоставить дополнительную информацию об объекте или обеспечить доступ к прототипу другого объекта.
//Существует также связанный с ним метод Object.setPrototypeOf(), который добавляет один прототип к другому объекту.
//Но вместо этого рекомендуется использовать Object.create(), поскольку он быстрее и эффективнее.

//==================================================11.СТРЕЛОЧНЫЕ ФУНКЦИИ.============================================//
//Стрелочные функции – это не просто «сокращение», чтобы меньше писать. У них есть ряд других полезных особенностей.
//При написании JavaScript-кода часто возникают ситуации, когда нам нужно написать небольшую функцию,
//которая будет выполнена где-то ещё.
 arr.forEach(func) – func выполняется forEach для каждого элемента массива.
 setTimeout(func) – func выполняется встроенным планировщиком.
// …и так далее.
//У стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.
    let group = {
 title: "Our Group",
 students: ["John", "Pete", "Alice"],

 showList() {
  this.students.forEach(
      student => alert(this.title + ': ' + student)
  );
 }
};

group.showList();

//Отсутствие this естественным образом ведёт к другому ограничению: стрелочные функции не могут быть использованы
//как конструкторы. Они не могут быть вызваны с new.

//Существует тонкая разница между стрелочной функцией => и обычной функцией, вызванной с .bind(this):
//.bind(this) создаёт «связанную версию» функции.
//Стрелка => ничего не привязывает. У функции просто нет this. При получении значения this – оно,
//как обычная переменная, берётся из внешнего лексического окружения.
//У стрелочных функций также нет переменной arguments.
//Это отлично подходит для декораторов, когда нам нужно пробросить вызов с текущими this и arguments.
//например, defer(f, ms) принимает функцию и возвращает обёртку над ней, которая откладывает вызов на ms миллисекунд

//у стрелочных функций нет super.(yнаследование классов).

//================================12.ОБРАБОТКА ОШИБОК,"TRY ... CATCH...FINALLY"=======================================//
//Обычно скрипт в случае ошибки «падает» (сразу же останавливается), с выводом ошибки в консоль.
// Но есть синтаксическая конструкция try..catch, которая позволяет «ловить» ошибки и вместо падения
//делать что-то более осмысленное.

//Конструкция try..catch состоит из двух основных блоков: try, и затем catch:
try {
 // код...
} catch (err) {
 // обработка ошибки
}
//Сначала выполняется код внутри блока try {...}.Если в нём нет ошибок, то блок catch(err) игнорируется:
//выполнение доходит до конца try и потом далее, полностью пропуская catch.Если же в нём возникает ошибка,
//то выполнение try прерывается, и поток управления переходит в начало catch(err).
//Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.
//Таким образом, при ошибке в блоке try {…} скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch.
try {
alert('Начало блока try');  // (1) <--
// ...код без ошибок
  alert('Конец блока try');   // (2) <--
} catch(err) {
alert('Catch игнорируется, так как нет ошибок'); // (3)

//Чтобы try..catch работал, код должен быть выполнимым. Другими словами, это должен быть корректный JavaScript-код.
//Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок

//JavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения,
//называются ошибками парсинга. Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.
//Таким образом, try..catch может обрабатывать только ошибки, которые возникают в корректном коде.
//Такие ошибки называют «ошибками во время выполнения», а иногда «исключениями».

//Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:
 try {
 setTimeout(function() {
 noSuchVariable; // скрипт упадёт тут
 }, 1000);
 } catch (e) {
 alert( "не сработает" );
 }
//Это потому, что функция выполняется позже, когда движок уже покинул конструкцию try..catch.
//Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:

//Конструкция try..catch может содержать ещё одну секцию: finally.Если секция есть, то она выполняется в любом случае:
// после try, если не было ошибок,
// после catch, если ошибки были.
 try {
//    ... пробуем выполнить код...
 } catch(e) {
//    ... обрабатываем ошибки ...
} finally {
//    ... выполняем всегда ...
}
//Секцию finally часто используют, когда мы начали что-то делать и хотим завершить это вне зависимости от того,
//будет ошибка или нет.
//Проброс исключения – это очень важный приём обработки ошибок: блок catch обычно ожидает и знает,
//как обработать определённый тип ошибок, поэтому он должен пробрасывать дальше ошибки, о которых он не знает.
//Даже если у нас нет try..catch, большинство сред позволяют настроить «глобальный» обработчик ошибок,
//чтобы ловить ошибки, которые «выпадают наружу». В браузере это window.onerror.

//==================================================13.PROTOTYPE.=====================================================//

//Новые объекты могут быть созданы с помощью функции-конструктора new F().
//Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
//F.prototype означает обычное свойство с именем "prototype" для F. Это ещё не «прототип объекта»,
//а обычное свойство F с таким именем.
 let animal = {
  eats: true
 };
   function Rabbit(name) {
     this.name = name;
 }
 Rabbit.prototype = animal;
  let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal
     alert( rabbit.eats ); // true
//Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее:
//"При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".

//F.prototype используется только при вызове new F() и присваивается в качестве свойства [[Prototype]] нового объекта.
//После этого F.prototype и новый объект ничего не связывает. Следует понимать это как «единоразовый подарок» объекту.
//После создания F.prototype может измениться, и новые объекты, созданные с помощью new F(), будут иметь другой объект
//в качестве [[Prototype]], но уже существующие объекты сохранят старый.

//У каждой функции по умолчанию уже есть свойство "prototype".По умолчанию "prototype" – объект с единственным
//свойством constructor, которое ссылается на функцию-конструктор.Kогда у нас есть объект, но мы не знаем,
//какой конструктор использовался для его создания (например, он мог быть взят из сторонней библиотеки),
//а нам необходимо создать ещё один такой объект.Но, пожалуй, самое важное о свойстве "constructor" это то, что…
//…JavaScript сам по себе не гарантирует правильное значение свойства "constructor".
//Да, оно является свойством по умолчанию в "prototype" у функций, но что случится с ним позже – зависит только от нас.
//В частности, если мы заменим прототип по умолчанию на другой объект, то свойства "constructor" в нём не будет.

//====================================================14.PROMISE======================================================//

//Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.
//Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»),
//затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
//onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
//onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
//Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.

//Внешний код, получив promise, навешивает на него обработчики.По завершении процесса асинхронный код переводит
//promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются
//соответствующие обработчики во внешнем коде.

//Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно
//написать .catch(onRejected) – это то же самое.

//Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject.
 'use strict';

// Создаётся объект promise
 let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
   // переведёт промис в состояние fulfilled с результатом "result"
   resolve("result");
  }, 1000);
 });
// promise.then навешивает обработчики на успешный результат или ошибку
 promise
     .then(
         result => {
          // первая функция-обработчик - запустится при вызове resolve
          alert("Fulfilled: " + result); // result - аргумент resolve
         },
         error => {
          // вторая функция - запустится при вызове reject
          alert("Rejected: " + error); // error - аргумент reject
         }
     );

//После вызова resolve/reject промис уже не может «передумать».Когда промис переходит в состояние «выполнен»
//– с результатом (resolve) или ошибкой (reject) – это навсегда.

//Промисификация – это когда берут асинхронную функциональность и делают для неё обёртку, возвращающую промис.После
//промисификации использование функциональности зачастую становится гораздо удобнее.В качестве примера сделаем такую
//обёртку для запросов при помощи XMLHttpRequest.Функция httpGet(url) будет возвращать промис, который при успешной
//загрузке данных с url будет переходить в fulfilled с этими данными, а при ошибке – в rejected с информацией об ошибке.

//Ряд современных браузеров уже поддерживает fetch – новый встроенный метод для AJAX-запросов, призванный заменить
//XMLHttpRequest. Он гораздо мощнее, чем httpGet. И – да, этот метод использует промисы. Полифил для него доступен
//на https://github.com/github/fetch.

//«Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина,
//из-за которой существуют и активно используются промисы.При чейнинге, то есть последовательных вызовах
//.then…then…then, в каждый следующий then переходит результат от предыдущего. Вызовы console.log оставлены,
//чтобы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.Если очередной then
//вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.

//При возникновении ошибки – она отправляется в ближайший обработчик onRejected.Такой обработчик нужно поставить через
//второй аргумент .then(..., onRejected) или, что то же самое, через .catch(onRejected).Чтобы поймать всевозможные
//ошибки, которые возникнут при загрузке и обработке данных, добавим catch в конец нашей цепочки.

//Согласно стандарту, у объекта new Promise(executor) при создании есть четыре внутренних свойства:
//PromiseState – состояние, вначале «pending».
//PromiseResult – результат, при создании значения нет.
//PromiseFulfillReactions – список функций-обработчиков успешного выполнения.
//PromiseRejectReactions – список функций-обработчиков ошибки.

//Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис,
//который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.

//Вызов Promise.race, как и Promise.all, получает итерируемый объект с промисами, которые нужно выполнить,
//и возвращает новый промис.Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся
//промис из списка. Остальные игнорируются.

//Вызов Promise.resolve(value) создаёт успешно выполнившийся промис с результатом value.
 new Promise((resolve) => resolve(value))

//Аналогично Promise.reject(error) создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой error.
 Promise.reject(new Error("..."))
     .catch(alert) // Error: ...

//=====================================================15.EVENT LOOP==================================================//

//Обработчики промисов .then/.catch/.finally всегда асинхронны.Даже когда промис сразу же выполнен, код в строках
//ниже .then/.catch/.finally будет запущен до этих обработчиков.
let promise = Promise.resolve();
promise.then(() => alert("промис выполнен"));
alert("код выполнен"); // этот alert показывается первым

//Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs,
//более известную как «очередь микрозадач (microtask queue)» (термин V8).
//Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
//Выполнение задачи происходит только в том случае, если ничего больше не запущено.
//Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь.
//Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

//После того как мы начали выполнять какой-либо script, в очередь Tasks ставится задача с выполнением этого скрипта.
//По мере выполнения этого кода, нам встречаются задачи от разных заказчиков, которые ставятся в соответствующие очереди
//После того как завершается задача по выполнению скрипта (задача от Tasks), Event Loop идет к Microtasks
//(после задачи от Tasks Event Loop берет задачи от Microtasks). У него Event Loop берет задачи до тех пор,
//пока они не закончатся. Это значит, что если время их добавления равно времени их выполнения, то
//Event Loop будет бесконечно их разгребать.Далее он идет к Render и выполняет задачи от него. Задачи от Render
//оптимизируются браузером и, если он посчитает, что в этом цикле не нужно ничего перерисовывать, то Event Loop
//просто пойдет дальше. Далее Event Loop снова берет задачи от Tasks и просит у него только одну,
//первую в очереди задачу, передает ее в CallStack и идет дальше по циклу.Если у кого-то из заказчиков не оказалось
//задач, то Event Loop просто идет к следующему. И, наоборот, если у заказчика задачи занимают много времени,
//то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными,
//то Call Stack переполняется, и браузер начинает ругаться.

//===================================================16.DOM.BOM.======================================================//

//Основой HTML-документа являются теги.В соответствии с объектной моделью документа («Document Object Model»,
//коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст,
//который находится внутри тега, также является объектом.Все эти объекты доступны при помощи JavaScript,
//мы можем использовать их для изменения страницы.Например, document.body – объект для тега <body>.
//DOM – это представление HTML-документа в виде дерева тегов.
 <!DOCTYPE HTML>
 <html>
 <head>
 <title>О лосях</title>
</head>
 <body>
 Правда о лосях.
 </body>
</html>
//Каждый узел этого дерева – это объект.Теги являются узлами-элементами (или просто элементами).Они образуют структуру
//дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.Текст внутри элементов образует
//текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста. У него не может быть
//потомков, т.е. он находится всегда на самом нижнем уровне.

//Все, что есть в HTML, даже комментарии, является частью DOM.Даже директива <!DOCTYPE...>, которую мы ставим в начале
//HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед <html>.Даже объект document, представляющий
//весь документ, формально является DOM-узлом.Существует 12 типов узлов. Но на практике мы в основном работаем
// с 4 из них:
//document – «входная точка» в DOM.
//Узлы-элементы – HTML-теги, основные строительные блоки.
//текстовые узлы – содержат текст.
//комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

//HTML/XML документы представлены в браузере в виде DOM-дерева.
//Теги становятся узлами-элементами и формируют структуру документа.
//Текст становится текстовыми узлами.
//… и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.
//Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

//===================================================BOM==============================================================//

//Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером
//(окружением), чтобы работать со всем, кроме документа.
//Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми
//известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform –
//информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
//Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.
//Функции alert/confirm/prompt тоже являются частью BOM: они не относятся непосредственно к странице, но представляют
//собой методы объекта окна браузера для коммуникации с пользователем.
//BOM является частью общей спецификации HTML.
 alert(location.href); // показывает текущий URL
 if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
 }

//========================================17.XMLHttpRequest: индикация прогресса.=====================================//
//Запрос XMLHttpRequest состоит из двух фаз:
//Стадия отправки (upload). На ней данные загружаются на сервер. Эта фаза может быть долгой для POST-запросов.
//Для отслеживания прогресса на стадии отправки существует объект типа XMLHttpRequestUpload, доступный как
//xhr.upload и события на нём.
//Стадия скачивания (download). После того, как данные загружены, браузер скачивает ответ с сервера. Если он большой,
//то это может занять существенное время. На этой стадии используется обработчик xhr.onprogress.

//На стадии отправки для получения информации используем объект xhr.upload. У этого объекта нет методов,
//он только генерирует события в процессе отправки. А они-то как раз и нужны.Вот полный список событий:loadstart//
//progress//abort//error//load//timeout//loadend
 xhr.upload.onprogress = function(event) {
  alert( 'Загружено на сервер ' + event.loaded + ' байт из ' + event.total );
 }
 xhr.upload.onload = function() {
  alert( 'Данные полностью загружены на сервер!' );
 }
 xhr.upload.onerror = function() {
  alert( 'Произошла ошибка при загрузке данных на сервер!' );
 }

//После того, как загрузка завершена, и сервер соизволит ответить на запрос, XMLHttpRequest начнёт скачивание
//ответа сервера.На этой фазе xhr.upload уже не нужен, а в дело вступают обработчики событий на самом объекте xhr.
//В частности, событие xhr.onprogress содержит информацию о количестве принятых байт ответа.
 xhr.onprogress = function(event) {
  alert( 'Получено с сервера ' + event.loaded + ' байт из ' + event.total );
 }
//Все события, возникающие в этих обработчиках, имеют тип ProgressEvent, то есть имеют свойства loaded
//– количество уже пересланных данных в байтах и total – общее количество данных.

//Современный XMLHttpRequest позволяет отправить на сервер всё, что угодно. Текст, файл, форму.Загрузка файла с
//индикацией прогресса.Это требует от браузера поддержки File API, то есть исключает IE9-.File API позволяет получить
//доступ к содержимому файла, который перенесён в браузер при помощи Drag’n’Drop или выбран в поле формы,
//и отправить его при помощи XMLHttpRequest.

//==============================================18.МЕТОДЫ HTTP, HTTPS=================================================//

//Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) - это прикладной протокол для передачи
//гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами,
//хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели,
//когда клиент открывает соединение для создания запроса, а затем ждёт ответа. HTTP - это протокол без сохранения
//состояния, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то,
//что HTTP основан на TCP/IP, он также может использовать любой другой протокол транспортного уровня с гарантированной
//доставкой.

//HTTPS (HTTP Secure) является зашифрованной версией HTTP протокола. Обычно он использует SSL (en-US) или TLS
//для шифрования соединения между клиентом и сервером. Это безопасное соединение позволяет клиентам безопасно
//обмениваться конфиденциальными данными с сервером, например, для банковских операций или онлайн-покупок.

//HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса.
//Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами.
//Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными,
//идемпотентными или кешируемыми.
//GET// Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
//HEAD//HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.
//POST//POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или
//какие-то побочные эффекты на сервере.
//PUT//PUT заменяет все текущие представления ресурса данными запроса.
//DELETE//DELETE удаляет указанный ресурс.
//CONNECT//CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.
//OPTIONS//OPTIONS используется для описания параметров соединения с ресурсом.
//TRACE//TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.
//PATCH//PATCH используется для частичного изменения ресурса.

//=======================================19.МЕТОДЫ JS ДЛЯ РАБОТЫ С ЭЛЕМЕНТАМИ DOM-ДЕРЕВА==============================//

//Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы
//(хотя события бывают и не только в DOM).
// События мыши:
// click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
// contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
// mouseover / mouseout – когда мышь наводится на / покидает элемент.
// mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
// mousemove – при движении мыши.

// События на элементах управления:
// submit – пользователь отправил форму <form>.
// focus – пользователь фокусируется на элементе, например нажимает на <input>.

// Клавиатурные события:
// keydown и keyup – когда пользователь нажимает / отпускает клавишу.

// События документа:
// DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.
// CSS events:
// transitionend – когда CSS-анимация завершена.

//Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную
//JavaScript-функцию и вызвать её там.
 <script>
  function countRabbits() {
  for(let i=1; i<=3; i++) {
  alert("Кролик номер " + i);
 }
 }
 </script>
//<input type="button" onClick="countRabbits()" value="Считать кроликов!">

//Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как говорят,
//«висит» (т.е. назначен) обработчик.В коде ниже button выводит своё содержимое, используя this.innerHTML
 <button onClick="alert(this.innerHTML)">Нажми меня</button>

//Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков
//при помощи специальных методов addEventListener и removeEventListener. Они свободны от указанного недостатка.
 element.addEventListener(event, handler[, options]);